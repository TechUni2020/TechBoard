"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const commands_1 = require("../commands");
const convertTagNameCase_1 = require("../commands/convertTagNameCase");
const htmlToPug_1 = require("../commands/htmlToPug");
const pugToHtml_1 = require("../commands/pugToHtml");
const showReferences_1 = require("../commands/showReferences");
const unuseRefSugar_1 = require("../commands/unuseRefSugar");
const useRefSugar_1 = require("../commands/useRefSugar");
function register(context, findReferences) {
    const { modules: { typescript: ts }, sourceFiles } = context;
    return async (uri, command, args, connection) => {
        if (command === commands_1.Commands.SHOW_REFERENCES && args) {
            await showReferences_1.execute(args[0], args[1], args[2], connection);
        }
        const sourceFile = sourceFiles.get(uri);
        if (!sourceFile)
            return;
        const document = sourceFile.getTextDocument();
        if (command === commands_1.Commands.USE_REF_SUGAR) {
            await useRefSugar_1.execute(ts, document, sourceFile, connection, findReferences);
        }
        if (command === commands_1.Commands.UNUSE_REF_SUGAR) {
            await unuseRefSugar_1.execute(connection, context, uri, findReferences);
        }
        if (command === commands_1.Commands.HTML_TO_PUG) {
            await htmlToPug_1.execute(document, sourceFile, connection);
        }
        if (command === commands_1.Commands.PUG_TO_HTML) {
            await pugToHtml_1.execute(document, sourceFile, connection);
        }
        if (command === commands_1.Commands.CONVERT_TO_KEBAB_CASE) {
            await convertTagNameCase_1.execute(connection, context, uri, findReferences, 'kebab');
        }
        if (command === commands_1.Commands.CONVERT_TO_PASCAL_CASE) {
            await convertTagNameCase_1.execute(connection, context, uri, findReferences, 'pascal');
        }
    };
}
exports.register = register;
//# sourceMappingURL=executeCommand.js.map