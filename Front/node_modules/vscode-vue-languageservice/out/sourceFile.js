"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceFile = exports.defaultLanguages = void 0;
const shared = require("@volar/shared");
const vueSfc = require("@vue/compiler-sfc");
const reactivity_1 = require("@vue/reactivity");
const vscode = require("vscode-languageserver");
const string_1 = require("./utils/string");
const untrack_1 = require("./utils/untrack");
const useSfcJsons_1 = require("./use/useSfcJsons");
const useSfcScript_1 = require("./use/useSfcScript");
const useSfcStyles_1 = require("./use/useSfcStyles");
const useSfcTemplate_1 = require("./use/useSfcTemplate");
const useSfcEntryForTemplateLs_1 = require("./use/useSfcEntryForTemplateLs");
const useSfcScriptGen_1 = require("./use/useSfcScriptGen");
const useSfcTemplateScript_1 = require("./use/useSfcTemplateScript");
exports.defaultLanguages = {
    template: 'html',
    script: 'js',
    style: 'css',
};
function createSourceFile(_document, context) {
    // refs
    const document = reactivity_1.ref(_document);
    const descriptor = reactivity_1.reactive({
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
    });
    const lastUpdated = {
        template: false,
        script: false,
        scriptSetup: false,
    };
    const templateScriptData = reactivity_1.reactive({
        projectVersion: undefined,
        context: [],
        components: [],
        props: [],
        setupReturns: [],
        htmlElements: [],
        componentItems: [],
        htmlElementItems: [],
    });
    const vueHtmlDocument = reactivity_1.computed(() => {
        return context.htmlLs.parseHTMLDocument(document.value);
    });
    const sfcErrors = reactivity_1.ref([]);
    // use
    const sfcStyles = useSfcStyles_1.useSfcStyles(context, untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.styles));
    const sfcJsons = useSfcJsons_1.useSfcJsons(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.customBlocks), context);
    const sfcTemplate = useSfcTemplate_1.useSfcTemplate(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.template), context);
    const sfcTemplateData = reactivity_1.computed(() => {
        if (sfcTemplate.pugDocument.value) {
            const pugDoc = sfcTemplate.pugDocument.value;
            return {
                sourceLang: 'pug',
                html: pugDoc.htmlCode,
                htmlToTemplate: (htmlStart, htmlEnd) => {
                    const pugRange = pugDoc.sourceMap.getSourceRange2(htmlStart, htmlEnd);
                    if (pugRange) {
                        return pugRange.start;
                    }
                },
            };
        }
        if (descriptor.template) {
            return {
                sourceLang: 'html',
                html: descriptor.template.content,
                htmlToTemplate: (htmlStart, _) => htmlStart,
            };
        }
    });
    const sfcTemplateScript = useSfcTemplateScript_1.useSfcTemplateScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.template), templateScriptData, sfcStyles.textDocuments, sfcStyles.sourceMaps, sfcTemplateData, context);
    const sfcScript = useSfcScript_1.useSfcScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.script));
    const sfcScriptSetup = useSfcScript_1.useSfcScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.scriptSetup));
    const sfcScriptForTemplateLs = useSfcScriptGen_1.useSfcScriptGen('template', context.modules.typescript, document, reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => { var _a; return (_a = sfcTemplateData.value) === null || _a === void 0 ? void 0 : _a.html; }));
    const sfcScriptForScriptLs = useSfcScriptGen_1.useSfcScriptGen('script', context.modules.typescript, document, reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => { var _a; return (_a = sfcTemplateData.value) === null || _a === void 0 ? void 0 : _a.html; }));
    const sfcEntryForTemplateLs = useSfcEntryForTemplateLs_1.useSfcEntryForTemplateLs(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => descriptor.template));
    // getters
    const cssLsDocuments = reactivity_1.computed(() => [
        sfcTemplateScript.cssTextDocument.value,
        ...sfcStyles.textDocuments.value,
    ].filter(shared.notEmpty));
    const cssLsSourceMaps = reactivity_1.computed(() => [
        sfcTemplateScript.cssSourceMap.value,
        ...sfcStyles.sourceMaps.value,
    ].filter(shared.notEmpty));
    const templateLsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForTemplateLs.sourceMap.value,
        sfcTemplateScript.sourceMap.value,
        sfcEntryForTemplateLs.sourceMap.value,
    ].filter(shared.notEmpty));
    const scriptLsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForScriptLs.sourceMap.value,
        sfcScriptForScriptLs.sourceMapForSuggestion.value,
    ].filter(shared.notEmpty));
    const templateLsDocuments = reactivity_1.computed(() => [
        sfcEntryForTemplateLs.textDocument.value,
        sfcScriptForTemplateLs.textDocument.value,
        sfcTemplateScript.textDocument.value,
    ].filter(shared.notEmpty));
    const scriptLsDocuments = reactivity_1.computed(() => [
        sfcScriptForScriptLs.textDocument.value,
        sfcScriptForScriptLs.textDocumentForSuggestion.value,
    ].filter(shared.notEmpty));
    const tsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForScriptLs.sourceMap.value,
        ...templateLsSourceMaps.value,
    ]);
    const templateLsTeleports = reactivity_1.computed(() => [
        sfcTemplateScript.teleportSourceMap.value,
        sfcScriptForTemplateLs.teleportSourceMap.value,
    ].filter(shared.notEmpty));
    update(_document);
    return {
        uri: _document.uri,
        getTemplateTagNames: untrack_1.untrack(() => { var _a; return (_a = sfcTemplateScript.templateCodeGens.value) === null || _a === void 0 ? void 0 : _a.tagNames; }),
        getTemplateAttrNames: untrack_1.untrack(() => { var _a; return (_a = sfcTemplateScript.templateCodeGens.value) === null || _a === void 0 ? void 0 : _a.attrNames; }),
        getTextDocument: untrack_1.untrack(() => document.value),
        getTemplateScriptDocument: untrack_1.untrack(() => sfcTemplateScript.textDocument.value),
        update: untrack_1.untrack(update),
        updateTemplateScript: untrack_1.untrack(updateTemplateScript),
        getScriptTsDocument: untrack_1.untrack(() => sfcScriptForScriptLs.textDocument.value),
        getScriptTsSourceMap: untrack_1.untrack(() => sfcScriptForScriptLs.sourceMap.value),
        getTsSourceMaps: untrack_1.untrack(() => tsSourceMaps.value),
        getCssSourceMaps: untrack_1.untrack(() => cssLsSourceMaps.value),
        getJsonSourceMaps: untrack_1.untrack(() => sfcJsons.sourceMaps.value),
        getHtmlSourceMaps: untrack_1.untrack(() => sfcTemplate.htmlSourceMap.value ? [sfcTemplate.htmlSourceMap.value] : []),
        getPugSourceMaps: untrack_1.untrack(() => sfcTemplate.pugSourceMap.value ? [sfcTemplate.pugSourceMap.value] : []),
        getTemplateScriptData: untrack_1.untrack(() => templateScriptData),
        getDescriptor: untrack_1.untrack(() => descriptor),
        getVueHtmlDocument: untrack_1.untrack(() => vueHtmlDocument.value),
        getScriptSetupData: untrack_1.untrack(() => sfcScriptForTemplateLs.scriptSetupRanges.value),
        docLsScripts: untrack_1.untrack(() => ({
            documents: [sfcScript.textDocument.value, sfcScriptSetup.textDocument.value].filter(shared.notEmpty),
            sourceMaps: [sfcScript.sourceMap.value, sfcScriptSetup.sourceMap.value].filter(shared.notEmpty),
        })),
        getTemplateFormattingScript: untrack_1.untrack(() => ({
            document: sfcTemplateScript.textDocumentForFormatting.value,
            sourceMap: sfcTemplateScript.sourceMapForFormatting.value,
        })),
        shouldVerifyTsScript: untrack_1.untrack(shouldVerifyTsScript),
        refs: {
            document,
            descriptor,
            lastUpdated,
            sfcErrors,
            sfcJsons,
            sfcTemplate,
            sfcTemplateScript,
            sfcScriptForScriptLs,
            sfcScriptForTemplateLs,
            templateScriptData,
            cssLsDocuments,
            cssLsSourceMaps,
            scriptLsDocuments,
            scriptLsSourceMaps,
            templateLsDocuments,
            templateLsSourceMaps,
            templateLsTeleports,
        },
    };
    function update(newDocument) {
        var _a, _b, _c, _d;
        const parsedSfc = vueSfc.parse(newDocument.getText(), { sourceMap: false, ignoreEmpty: false });
        const newDescriptor = parsedSfc.descriptor;
        const versionsBeforeUpdate = [
            (_a = sfcScriptForTemplateLs.textDocument.value) === null || _a === void 0 ? void 0 : _a.version,
            (_b = sfcTemplateScript.textDocument.value) === null || _b === void 0 ? void 0 : _b.version,
        ];
        updateSfcErrors();
        updateTemplate(newDescriptor);
        updateScript(newDescriptor);
        updateScriptSetup(newDescriptor);
        updateStyles(newDescriptor);
        updateCustomBlocks(newDescriptor);
        if (newDocument.getText() !== document.value.getText()) {
            document.value = newDocument;
        }
        sfcTemplateScript.update(sfcScriptForScriptLs.lang.value); // TODO
        const versionsAfterUpdate = [
            (_c = sfcScriptForTemplateLs.textDocument.value) === null || _c === void 0 ? void 0 : _c.version,
            (_d = sfcTemplateScript.textDocument.value) === null || _d === void 0 ? void 0 : _d.version,
        ];
        return {
            scriptUpdated: versionsBeforeUpdate[0] !== versionsAfterUpdate[0],
            templateScriptUpdated: versionsBeforeUpdate[1] !== versionsAfterUpdate[1],
        };
        function updateSfcErrors() {
            const errors = [];
            for (const error of parsedSfc.errors) {
                if ('code' in error && error.loc) {
                    const diag = vscode.Diagnostic.create(vscode.Range.create(error.loc.start.line - 1, error.loc.start.column - 1, error.loc.end.line - 1, error.loc.end.column - 1), error.message, vscode.DiagnosticSeverity.Error, error.code, 'vue');
                    errors.push(diag);
                }
            }
            sfcErrors.value = errors;
        }
        function updateTemplate(newDescriptor) {
            var _a, _b;
            const newData = newDescriptor.template ? {
                lang: (_a = newDescriptor.template.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.template,
                content: newDescriptor.template.content,
                loc: {
                    start: newDescriptor.template.loc.start.offset,
                    end: newDescriptor.template.loc.end.offset,
                },
            } : null;
            lastUpdated.template = ((_b = descriptor.template) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.template && newData) {
                descriptor.template.lang = newData.lang;
                descriptor.template.content = newData.content;
                descriptor.template.loc.start = newData.loc.start;
                descriptor.template.loc.end = newData.loc.end;
            }
            else {
                descriptor.template = newData;
            }
        }
        function updateScript(newDescriptor) {
            var _a, _b;
            const newData = newDescriptor.script ? {
                src: newDescriptor.script.src,
                lang: (_a = newDescriptor.script.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.script,
                content: newDescriptor.script.content,
                loc: {
                    start: newDescriptor.script.loc.start.offset,
                    end: newDescriptor.script.loc.end.offset,
                },
            } : null;
            lastUpdated.script = ((_b = descriptor.script) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.script && newData) {
                descriptor.script.src = newData.src;
                descriptor.script.lang = newData.lang;
                descriptor.script.content = newData.content;
                descriptor.script.loc.start = newData.loc.start;
                descriptor.script.loc.end = newData.loc.end;
            }
            else {
                descriptor.script = newData;
            }
        }
        function updateScriptSetup(newDescriptor) {
            var _a, _b;
            const newData = newDescriptor.scriptSetup ? {
                lang: (_a = newDescriptor.scriptSetup.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.script,
                content: newDescriptor.scriptSetup.content,
                loc: {
                    start: newDescriptor.scriptSetup.loc.start.offset,
                    end: newDescriptor.scriptSetup.loc.end.offset,
                },
            } : null;
            lastUpdated.scriptSetup = ((_b = descriptor.scriptSetup) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.scriptSetup && newData) {
                descriptor.scriptSetup.lang = newData.lang;
                descriptor.scriptSetup.content = newData.content;
                descriptor.scriptSetup.loc.start = newData.loc.start;
                descriptor.scriptSetup.loc.end = newData.loc.end;
            }
            else {
                descriptor.scriptSetup = newData;
            }
        }
        function updateStyles(newDescriptor) {
            var _a;
            for (let i = 0; i < newDescriptor.styles.length; i++) {
                const style = newDescriptor.styles[i];
                const newData = {
                    lang: (_a = style.lang) !== null && _a !== void 0 ? _a : exports.defaultLanguages.style,
                    content: style.content,
                    loc: {
                        start: style.loc.start.offset,
                        end: style.loc.end.offset,
                    },
                    module: !!style.module,
                    scoped: !!style.scoped,
                };
                if (descriptor.styles.length > i) {
                    descriptor.styles[i].lang = newData.lang;
                    descriptor.styles[i].content = newData.content;
                    descriptor.styles[i].loc.start = newData.loc.start;
                    descriptor.styles[i].loc.end = newData.loc.end;
                    descriptor.styles[i].module = newData.module;
                    descriptor.styles[i].scoped = newData.scoped;
                }
                else {
                    descriptor.styles.push(newData);
                }
            }
            while (descriptor.styles.length > newDescriptor.styles.length) {
                descriptor.styles.pop();
            }
        }
        function updateCustomBlocks(newDescriptor) {
            var _a;
            for (let i = 0; i < newDescriptor.customBlocks.length; i++) {
                const block = newDescriptor.customBlocks[i];
                const newData = {
                    type: block.type,
                    lang: (_a = block.lang) !== null && _a !== void 0 ? _a : '',
                    content: block.content,
                    loc: {
                        start: block.loc.start.offset,
                        end: block.loc.end.offset,
                    },
                };
                if (descriptor.customBlocks.length > i) {
                    descriptor.customBlocks[i].type = newData.type;
                    descriptor.customBlocks[i].lang = newData.lang;
                    descriptor.customBlocks[i].content = newData.content;
                    descriptor.customBlocks[i].loc.start = newData.loc.start;
                    descriptor.customBlocks[i].loc.end = newData.loc.end;
                }
                else {
                    descriptor.customBlocks.push(newData);
                }
            }
            while (descriptor.customBlocks.length > newDescriptor.customBlocks.length) {
                descriptor.customBlocks.pop();
            }
        }
    }
    function updateTemplateScript(templateTsLs) {
        var _a, _b;
        const newVersion = (_b = (_a = templateTsLs.__internal__.host).getProjectVersion) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (templateScriptData.projectVersion === newVersion) {
            return false;
        }
        templateScriptData.projectVersion = newVersion;
        const doc = sfcEntryForTemplateLs.textDocument.value;
        const docText = doc.getText();
        const context = docText.indexOf(string_1.SearchTexts.Context) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Context))) : [];
        let components = docText.indexOf(string_1.SearchTexts.Components) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Components))) : [];
        const props = docText.indexOf(string_1.SearchTexts.Props) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Props))) : [];
        const setupReturns = docText.indexOf(string_1.SearchTexts.SetupReturns) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.SetupReturns))) : [];
        const globalEls = docText.indexOf(string_1.SearchTexts.HtmlElements) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(doc.getText().indexOf(string_1.SearchTexts.HtmlElements))) : [];
        components = components.filter(entry => {
            const name = entry.data.name;
            return name.indexOf('$') === -1 && !name.startsWith('_');
        });
        const contextNames = context.map(entry => entry.data.name);
        const componentNames = components.map(entry => entry.data.name);
        const propNames = props.map(entry => entry.data.name);
        const setupReturnNames = setupReturns.map(entry => entry.data.name);
        const htmlElementNames = globalEls.map(entry => entry.data.name);
        if (shared.eqSet(new Set(contextNames), new Set(templateScriptData.context))
            && shared.eqSet(new Set(componentNames), new Set(templateScriptData.components))
            && shared.eqSet(new Set(propNames), new Set(templateScriptData.props))
            && shared.eqSet(new Set(setupReturnNames), new Set(templateScriptData.setupReturns))
            && shared.eqSet(new Set(htmlElementNames), new Set(templateScriptData.htmlElements))) {
            return false;
        }
        templateScriptData.context = contextNames;
        templateScriptData.components = componentNames;
        templateScriptData.props = propNames;
        templateScriptData.setupReturns = setupReturnNames;
        templateScriptData.htmlElements = htmlElementNames;
        templateScriptData.componentItems = components;
        templateScriptData.htmlElementItems = globalEls;
        sfcTemplateScript.update(sfcScriptForScriptLs.lang.value); // TODO
        return true;
    }
    function shouldVerifyTsScript(templateTsHost, tsUri, mode) {
        var _a, _b;
        if (tsUri.toLowerCase() === ((_a = sfcScriptForTemplateLs.textDocumentForSuggestion.value) === null || _a === void 0 ? void 0 : _a.uri.toLowerCase())) {
            if (mode === 3) {
                return 'all';
            }
            if (mode === 1) {
                const tsOptions = templateTsHost.getCompilationSettings();
                const anyNoUnusedEnabled = tsOptions.noUnusedLocals || tsOptions.noUnusedParameters;
                return anyNoUnusedEnabled ? 'unused' : 'none';
            }
            return 'none';
        }
        if (tsUri.toLowerCase() === ((_b = sfcScriptForTemplateLs.textDocument.value) === null || _b === void 0 ? void 0 : _b.uri.toLowerCase())) {
            if (mode === 3) {
                return !sfcScriptForTemplateLs.textDocumentForSuggestion.value ? 'all' : 'none';
            }
            return 'all';
        }
        return 'all';
    }
}
exports.createSourceFile = createSourceFile;
//# sourceMappingURL=sourceFile.js.map