"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const vscode = require("vscode-languageserver");
const shared = require("@volar/shared");
const rename_1 = require("./rename");
const fixNames = require("../utils/fixNames");
function register(languageService, getTextDocument, host) {
    return async (uri, range, context) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const document = getTextDocument(uri);
        if (!document)
            return;
        const [formatOptions, preferences] = await Promise.all([
            (_b = (_a = host.getFormatOptions) === null || _a === void 0 ? void 0 : _a.call(host, document)) !== null && _b !== void 0 ? _b : {},
            (_d = (_c = host.getPreferences) === null || _c === void 0 ? void 0 : _c.call(host, document)) !== null && _d !== void 0 ? _d : {},
        ]);
        const fileName = shared.uriToFsPath(document.uri);
        const start = document.offsetAt(range.start);
        const end = document.offsetAt(range.start);
        const errorCodes = context.diagnostics.map(error => error.code);
        let result = [];
        if (!context.only
            || context.only.includes(vscode.CodeActionKind.QuickFix)) {
            try {
                const codeFixes = languageService.getCodeFixesAtPosition(fileName, start, end, errorCodes, formatOptions, preferences);
                for (const codeFix of codeFixes) {
                    result = result.concat(transformCodeFix(codeFix));
                }
            }
            catch { }
        }
        if (((_e = context.only) === null || _e === void 0 ? void 0 : _e.includes(vscode.CodeActionKind.Refactor))
            || ((_f = context.only) === null || _f === void 0 ? void 0 : _f.includes(vscode.CodeActionKind.RefactorExtract))
            || ((_g = context.only) === null || _g === void 0 ? void 0 : _g.includes(vscode.CodeActionKind.RefactorInline))
            || ((_h = context.only) === null || _h === void 0 ? void 0 : _h.includes(vscode.CodeActionKind.RefactorRewrite))) {
            try {
                const refactors = languageService.getApplicableRefactors(fileName, { pos: start, end: end }, preferences, undefined /* TODO */, undefined /* TODO */);
                for (const refactor of refactors) {
                    result = result.concat(transformRefactor(refactor));
                }
            }
            catch { }
        }
        if (((_j = context.only) === null || _j === void 0 ? void 0 : _j.includes(vscode.CodeActionKind.Source))
            || ((_k = context.only) === null || _k === void 0 ? void 0 : _k.includes(vscode.CodeActionKind.SourceOrganizeImports))) {
            try {
                const changes = languageService.organizeImports({ type: 'file', fileName: fileName }, formatOptions, preferences);
                const edit = rename_1.fileTextChangesToWorkspaceEdit(changes, getTextDocument);
                result.push(vscode.CodeAction.create('Organize Imports', edit, vscode.CodeActionKind.SourceOrganizeImports));
            }
            catch { }
        }
        if (((_l = context.only) === null || _l === void 0 ? void 0 : _l.includes(vscode.CodeActionKind.Source))
            || ((_m = context.only) === null || _m === void 0 ? void 0 : _m.includes(vscode.CodeActionKind.SourceFixAll))) {
            const action = vscode.CodeAction.create('Fix All', vscode.CodeActionKind.SourceFixAll);
            const data = {
                uri,
                type: 'fixAll',
                fileName,
                fixIds: [
                    fixNames.classIncorrectlyImplementsInterface,
                    fixNames.awaitInSyncFunction,
                    fixNames.unreachableCode,
                ],
            };
            action.data = data;
            result.push(action);
        }
        if ((_o = context.only) === null || _o === void 0 ? void 0 : _o.includes(vscode.CodeActionKind.Source)) {
            {
                const action = vscode.CodeAction.create('Remove all unused code', vscode.CodeActionKind.SourceFixAll);
                const data = {
                    uri,
                    type: 'fixAll',
                    fileName,
                    fixIds: [
                        // not working and throw
                        fixNames.unusedIdentifier,
                        // TODO: remove patching
                        'unusedIdentifier_prefix',
                        'unusedIdentifier_deleteImports',
                        'unusedIdentifier_delete',
                        'unusedIdentifier_infer',
                    ],
                };
                action.data = data;
                result.push(action);
            }
            {
                const action = vscode.CodeAction.create('Add all missing imports', vscode.CodeActionKind.SourceFixAll);
                const data = {
                    uri,
                    type: 'fixAll',
                    fileName,
                    fixIds: [
                        // not working and throw
                        fixNames.fixImport,
                        // TODO: remove patching
                        'fixMissingImport',
                    ],
                };
                action.data = data;
                result.push(action);
            }
        }
        for (const codeAction of result) {
            codeAction.diagnostics = context.diagnostics;
        }
        return result;
        function transformCodeFix(codeFix) {
            const edit = rename_1.fileTextChangesToWorkspaceEdit(codeFix.changes, getTextDocument);
            const codeActions = [];
            const fix = vscode.CodeAction.create(codeFix.description, edit, vscode.CodeActionKind.QuickFix);
            codeActions.push(fix);
            if (codeFix.fixAllDescription && codeFix.fixId) {
                const fixAll = vscode.CodeAction.create(codeFix.fixAllDescription, vscode.CodeActionKind.QuickFix);
                const data = {
                    uri,
                    type: 'fixAll',
                    fileName,
                    fixIds: [codeFix.fixId],
                };
                fixAll.data = data;
                codeActions.push(fixAll);
            }
            return codeActions;
        }
        function transformRefactor(refactor) {
            const codeActions = [];
            for (const action of refactor.actions) {
                const codeAction = vscode.CodeAction.create(action.name, vscode.CodeActionKind.Refactor);
                const data = {
                    uri,
                    type: 'refactor',
                    fileName,
                    range: { pos: start, end: end },
                    refactorName: refactor.name,
                    actionName: action.name,
                };
                codeAction.data = data;
                if (action.notApplicableReason) {
                    codeAction.disabled = { reason: action.notApplicableReason };
                }
                if (refactor.inlineable) {
                    codeAction.isPreferred = true;
                }
                codeActions.push(codeAction);
            }
            return codeActions;
        }
    };
}
exports.register = register;
//# sourceMappingURL=codeAction.js.map